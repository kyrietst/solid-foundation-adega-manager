# üîç RELAT√ìRIO DETALHADO DE BUGS NO SISTEMA DE ESTOQUE

## üìÖ **Data da An√°lise:** 20/09/2025
## üî¨ **Tipo:** An√°lise Completa de Sistema
## ‚ö†Ô∏è **Severidade:** CR√çTICA - Sistema em Produ√ß√£o Afetado

---

## üéØ **RESUMO EXECUTIVO**

O sistema de gest√£o de estoque apresenta **m√∫ltiplas l√≥gicas conflitantes** que resultam em subtra√ß√£o incorreta do estoque durante vendas. O problema identificado √© uma **arquitetura h√≠brida** onde diferentes partes do sistema usam diferentes estrat√©gias de controle de estoque, criando interfer√™ncias e duplica√ß√µes.

### **Impacto Observado:**
- ‚ùå Venda de 1 pacote + 1 unidade resulta em subtra√ß√£o de 4 unidades soltas
- ‚ùå Pacotes n√£o s√£o debitados de `stock_packages`
- ‚ùå Sistema n√£o funciona como "conta de 5¬™ s√©rie" esperada
- ‚ùå Inconsist√™ncias entre dados exibidos e estoque real

---

## üîç **PROBLEMAS IDENTIFICADOS**

### **1. üö® CONFLITO DE TRIGGERS (Problema Principal)**

#### **A. Trigger Duplicado de Subtra√ß√£o:**
- **`trigger_update_variant_stock`** (linha 10473) ‚Üí executa ap√≥s INSERT em `sale_items`
- **`trg_adjust_stock`** (linha 10437) ‚Üí executa ap√≥s INSERT em `inventory_movements`

#### **B. Fluxo de Duplica√ß√£o Identificado:**
```mermaid
graph TD
    A[process_sale] --> B[INSERT sale_items]
    A --> C[INSERT inventory_movements]
    B --> D[trigger_update_variant_stock]
    C --> E[trg_adjust_stock]
    D --> F[Subtrai estoque variants]
    E --> G[Subtrai stock_quantity]
    F --> H[DUPLICA√á√ÉO!]
    G --> H
```

### **2. üîß FUN√á√ïES COM L√ìGICAS CONFLITANTES**

#### **A. `adjust_product_stock()` (linhas 178-195)**
```sql
-- PROBLEMA: S√≥ trabalha com stock_quantity geral
IF NEW.type IN ('out', 'fiado') THEN
    UPDATE products
    SET stock_quantity = stock_quantity - NEW.quantity  -- ‚ùå SEMPRE stock_quantity
    WHERE id = NEW.product_id;
```

**Problemas:**
- ‚ùå N√£o diferencia entre pacotes e unidades
- ‚ùå Sempre subtrai de `stock_quantity` independente do tipo
- ‚ùå Ignora metadados sobre tipo de movimento

#### **B. `update_variant_stock_after_sale()` (linhas 8026-8100)**
```sql
-- Reduzir estoque da variante vendida
UPDATE product_variants
SET stock_quantity = stock_quantity - NEW.quantity  -- ‚ùå Sempre variants
WHERE id = NEW.variant_id;
```

**Problemas:**
- ‚ùå Trabalha apenas com `product_variants.stock_quantity`
- ‚ùå N√£o atualiza `products.stock_packages` ou `products.stock_units_loose`
- ‚ùå Sistema h√≠brido: variants vs produtos principais

### **3. üìä INCONSIST√äNCIA ARQUITETURAL**

#### **A. M√∫ltiplos Sistemas de Estoque Coexistindo:**

1. **Sistema Legado (products table):**
   - `stock_quantity` (geral)
   - `stock_packages`
   - `stock_units_loose`

2. **Sistema de Variantes (product_variants table):**
   - `stock_quantity` por variante
   - `variant_type: 'unit' | 'package'`

3. **Interface Frontend:**
   - Exibe `stock_packages` e `stock_units_loose` (sistema legado)
   - Trabalha com `variant_id` (sistema novo)

#### **B. Mapeamento Inconsistente:**
```typescript
// Frontend exibe (legado):
stock_packages: 2
stock_units_loose: 2187

// Backend processa (novo):
variant_id: "product-id-package" ‚Üí product_variants.stock_quantity
variant_id: "product-id-unit" ‚Üí product_variants.stock_quantity
```

### **4. üîÑ PROCEDIMENTOS COM L√ìGICAS DUPLICADAS**

#### **A. `process_sale()` - M√∫ltiplas Chamadas de Subtra√ß√£o:**
```sql
-- 1. Chama create_inventory_movement()
v_movement_result := create_inventory_movement(...);

-- 2. Que insere em inventory_movements
INSERT INTO inventory_movements (...)

-- 3. Que ativa trigger trg_adjust_stock
-- 4. Que chama adjust_product_stock()
-- 5. Que subtrai de stock_quantity

-- MAIS:
-- 6. INSERT em sale_items
-- 7. Ativa trigger_update_variant_stock
-- 8. Que subtrai de product_variants.stock_quantity
```

### **5. üé≠ MODAL DE AJUSTE INDEPENDENTE**

#### **A. `StockAdjustmentModal.tsx` - Sistema Paralelo:**
- Chama `set_product_stock_absolute()`
- Trabalha diretamente com `stock_packages` e `stock_units_loose`
- **N√ÉO passa pelos triggers conflitantes**
- Por isso funciona corretamente

#### **B. Evid√™ncia de Sistema H√≠brido:**
```typescript
// Modal exibe corretamente:
stock_packages: 2 ‚Üí 1 (ap√≥s ajuste manual)

// Vendas n√£o funcionam:
stock_packages: 2 ‚Üí 2 (ap√≥s venda de 1 pacote)
stock_units_loose: 2187 ‚Üí 2183 (subtra√ß√£o incorreta)
```

---

## üî¨ **AN√ÅLISE T√âCNICA DETALHADA**

### **1. Evid√™ncias do Conflito:**

#### **A. Logs de Vendas Analisados:**
- Venda ID: `57161a4f-7744-43b8-aa00-1108a982d10c`
- **Esperado:** 1 movimento "package" + 1 movimento "unit"
- **Real:** 2 movimentos "unit" + 0 movimentos "package"

#### **B. Movimentos de Estoque Gerados:**
```json
// Movimento 1 (INCORRETO):
{
  "previous_stock": 2191,
  "new_stock_quantity": 2190,
  "metadata": {
    "movement_type": "unit",
    "sale_type": "unit"  // ‚ùå Deveria ser "package"
  }
}

// Movimento 2 (CORRETO):
{
  "previous_stock": 2189,  // ‚ùå J√° foi alterado pelo movimento 1
  "new_stock_quantity": 2188,
  "metadata": {
    "movement_type": "unit",
    "sale_type": "unit"
  }
}
```

### **2. Triggers Ativos Identificados:**

```sql
-- TRIGGER 1: Sale Items ‚Üí Variants
CREATE TRIGGER "trigger_update_variant_stock"
    AFTER INSERT ON "sale_items"
    FOR EACH ROW
    EXECUTE FUNCTION "update_variant_stock_after_sale"();

-- TRIGGER 2: Inventory Movements ‚Üí Products
CREATE TRIGGER "trg_adjust_stock"
    AFTER INSERT ON "inventory_movements"
    FOR EACH ROW
    EXECUTE FUNCTION "adjust_product_stock"();
```

### **3. Fun√ß√µes com Problemas:**

#### **A. `adjust_product_stock()` - L√≥gica Ultrapassada:**
```sql
-- ‚ùå PROBLEMA: N√£o considera metadados
UPDATE products
SET stock_quantity = stock_quantity - NEW.quantity
WHERE id = NEW.product_id;

-- ‚úÖ DEVERIA SER:
IF (NEW.metadata->>'movement_type' = 'package') THEN
    UPDATE products
    SET stock_packages = stock_packages - NEW.quantity
    WHERE id = NEW.product_id;
ELSIF (NEW.metadata->>'movement_type' = 'unit') THEN
    UPDATE products
    SET stock_units_loose = stock_units_loose - NEW.quantity
    WHERE id = NEW.product_id;
END IF;
```

#### **B. `update_variant_stock_after_sale()` - Sistema Paralelo:**
```sql
-- ‚ùå PROBLEMA: Atualiza variants, n√£o produtos principais
UPDATE product_variants
SET stock_quantity = stock_quantity - NEW.quantity
WHERE id = NEW.variant_id;

-- ‚úÖ DEVERIA SER: Integrar com sistema principal ou desabilitar
```

---

## üõ†Ô∏è **SOLU√á√ïES PROPOSTAS**

### **OP√á√ÉO 1: üéØ CORRE√á√ÉO R√ÅPIDA (Recomendada)**

#### **A. Desabilitar Trigger Conflitante:**
```sql
DROP TRIGGER IF EXISTS "trigger_update_variant_stock" ON "public"."sale_items";
```

#### **B. Corrigir `adjust_product_stock()`:**
```sql
CREATE OR REPLACE FUNCTION "public"."adjust_product_stock"()
RETURNS trigger AS $$
BEGIN
  -- Verificar tipo de movimento via metadados
  IF NEW.metadata->>'movement_type' = 'package' THEN
    -- Atualizar pacotes
    IF NEW.type IN ('in', 'devolucao') THEN
      UPDATE products
      SET stock_packages = stock_packages + NEW.quantity,
          updated_at = NOW()
      WHERE id = NEW.product_id;
    ELSIF NEW.type IN ('out', 'fiado') THEN
      UPDATE products
      SET stock_packages = stock_packages - NEW.quantity,
          updated_at = NOW()
      WHERE id = NEW.product_id;
    END IF;
  ELSE
    -- Atualizar unidades (comportamento padr√£o)
    IF NEW.type IN ('in', 'devolucao') THEN
      UPDATE products
      SET stock_units_loose = stock_units_loose + NEW.quantity,
          updated_at = NOW()
      WHERE id = NEW.product_id;
    ELSIF NEW.type IN ('out', 'fiado') THEN
      UPDATE products
      SET stock_units_loose = stock_units_loose - NEW.quantity,
          updated_at = NOW()
      WHERE id = NEW.product_id;
    END IF;
  END IF;

  -- Atualizar stock_quantity (calculado)
  UPDATE products
  SET stock_quantity = (stock_packages * COALESCE(package_units, units_per_package, 1)) + stock_units_loose
  WHERE id = NEW.product_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### **OP√á√ÉO 2: üîÑ REFATORA√á√ÉO COMPLETA**

#### **A. Unificar Sistema de Estoque:**
- Migrar completamente para `product_variants`
- Depreciar `stock_packages` e `stock_units_loose`
- Atualizar frontend para trabalhar apenas com variants

#### **B. Criar Fun√ß√£o de Sincroniza√ß√£o:**
```sql
CREATE OR REPLACE FUNCTION sync_product_stock_from_variants()
RETURNS trigger AS $$
BEGIN
  UPDATE products
  SET
    stock_packages = (
      SELECT COALESCE(stock_quantity, 0)
      FROM product_variants
      WHERE product_id = NEW.product_id
        AND variant_type = 'package'
        AND is_active = true
    ),
    stock_units_loose = (
      SELECT COALESCE(stock_quantity, 0)
      FROM product_variants
      WHERE product_id = NEW.product_id
        AND variant_type = 'unit'
        AND is_active = true
    )
  WHERE id = NEW.product_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## üìã **PLANO DE IMPLEMENTA√á√ÉO**

### **FASE 1: üö® CORRE√á√ÉO IMEDIATA**
1. **Backup completo** da base de dados
2. **Desabilitar** `trigger_update_variant_stock`
3. **Corrigir** fun√ß√£o `adjust_product_stock()`
4. **Testar** com venda de 1 pacote + 1 unidade
5. **Validar** que resultado √© correto

### **FASE 2: üß™ TESTES EXTENSIVOS**
1. **Testar cen√°rios:**
   - Venda apenas de unidades
   - Venda apenas de pacotes
   - Venda mista (pacotes + unidades)
   - Devolu√ß√µes
   - Ajustes manuais de estoque
2. **Verificar integridade:**
   - Movimentos de estoque corretos
   - Sem duplica√ß√µes
   - Frontend exibe valores corretos

### **FASE 3: üéØ OTIMIZA√á√ÉO**
1. **Limpar c√≥digo legado**
2. **Otimizar performance**
3. **Documentar arquitetura final**
4. **Treinar equipe**

---

## ‚ö†Ô∏è **RISCOS E CONSIDERA√á√ïES**

### **RISCOS ALTOS:**
- üî¥ **Dados hist√≥ricos**: Movimentos passados podem estar incorretos
- üî¥ **Depend√™ncias**: Outros sistemas podem depender da estrutura atual
- üî¥ **Downtime**: Corre√ß√£o pode requerer interrup√ß√£o do sistema

### **RISCOS M√âDIOS:**
- üü° **Performance**: Trigger corrigido pode ser mais lento
- üü° **Complexidade**: L√≥gica mais complexa para manuten√ß√£o
- üü° **Testes**: Cobertura de testes insuficiente

### **MITIGA√á√ïES:**
- ‚úÖ **Backup completo** antes de qualquer altera√ß√£o
- ‚úÖ **Ambiente de teste** para valida√ß√£o pr√©via
- ‚úÖ **Rollback plan** preparado
- ‚úÖ **Monitoramento** ativo ap√≥s implementa√ß√£o

---

## üìä **M√âTRICAS DE SUCESSO**

### **Crit√©rios de Aceita√ß√£o:**
1. ‚úÖ Venda de 1 pacote = -1 `stock_packages`
2. ‚úÖ Venda de 1 unidade = -1 `stock_units_loose`
3. ‚úÖ Sem movimentos duplicados
4. ‚úÖ Frontend exibe valores corretos
5. ‚úÖ Performance mantida ou melhorada

### **Testes de Regress√£o:**
```sql
-- TESTE 1: Venda Simples
-- ANTES: stock_packages=2, stock_units_loose=2187
-- A√á√ÉO: Vender 1 pacote
-- ESPERADO: stock_packages=1, stock_units_loose=2187

-- TESTE 2: Venda Mista
-- ANTES: stock_packages=2, stock_units_loose=2187
-- A√á√ÉO: Vender 1 pacote + 1 unidade
-- ESPERADO: stock_packages=1, stock_units_loose=2186

-- TESTE 3: Movimentos de Estoque
-- A√á√ÉO: Consultar inventory_movements
-- ESPERADO: 1 movimento "package" + 1 movimento "unit"
```

---

## üéØ **CONCLUS√ÉO**

O problema identificado √© **arquitetural** e **sistem√°tico**, n√£o pontual. A coexist√™ncia de m√∫ltiplos sistemas de controle de estoque (legado + variants + triggers) criou um ambiente onde **l√≥gicas conflitantes** executam simultaneamente, resultando em **duplica√ß√µes** e **inconsist√™ncias**.

A **solu√ß√£o recomendada** √© a **Op√ß√£o 1 (Corre√ß√£o R√°pida)**, que:
- ‚úÖ Resolve o problema imediatamente
- ‚úÖ Mant√©m compatibilidade com c√≥digo existente
- ‚úÖ Minimiza riscos de regress√£o
- ‚úÖ Permite evolu√ß√£o gradual do sistema

A implementa√ß√£o deve ser feita **imediatamente** devido √† severidade do problema e impacto em produ√ß√£o.

---

## üìé **ANEXOS**

### **A. Evid√™ncias Coletadas:**
- Logs de vendas com IDs espec√≠ficos
- Movimentos de estoque duplicados
- Screenshots do comportamento incorreto
- An√°lise de c√≥digo fonte completa

### **B. Arquivos Afetados:**
- `backup_completo.sql` (triggers e fun√ß√µes)
- `src/features/sales/hooks/use-sales.ts` (frontend)
- `src/features/inventory/components/StockAdjustmentModal.tsx` (modal)

### **C. Refer√™ncias T√©cnicas:**
- Documenta√ß√£o PostgreSQL sobre triggers
- Boas pr√°ticas para controle de estoque
- Padr√µes de arquitetura para sistemas h√≠bridos

---

**üìÖ Relat√≥rio gerado em:** 20/09/2025 √†s 07:45 BRT
**üë®‚Äçüíª Analista:** Claude Code Assistant
**üîç Vers√£o:** 1.0 - An√°lise Completa
**‚ö° Status:** CR√çTICO - A√ß√£o Imediata Requerida